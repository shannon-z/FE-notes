# 第四章 变量 作用域和内存  
## 基本类型和引用类型的值  
JavaScript 变量松散类型的本质, 决定了它只是在特定时间用于保存特定值的一个名字而已.  
ECMAScript 变量包含两种数据类型的值: 基本类型值和引用类型值.  
- 基本类型值: 简单的数据段
- 引用类型值: 可能由多个值构成的对象  

在将一个值赋给变量时, 解析器必须确定这个值是基本类型值还是引用类型值. 五种基本数据类型:Undefined, Null, Boolean, Number, String. 这五种基本数据类型是按值访问的, 因为可以操作保存在变量中的实际的值.  
引用类型的值是保存在内存中的对象, 与其他语言不同, JavaScript不允许直接访问内存中的位置, 也就是说不能直接操作对象的内存空间. 在操作对象时, 实际上是在操作对象的引用而不是实际的对象. 为此, 引用类型的值是按引用访问的(这种说法不严密, 在复制保存着对象的某个变量时, 操作的是对象的引用, 但在为对象添加属性时, 操作的是实际的对象.)  

JavaScript中字符串不是以对象形式来表示, 不是引用类型.  

### 动态的属性  
定义基本数据类型值和引用数据类型值的方式是类似的: 创建一个变量并为该变量赋值.  
当这个值保存到变量中, 对不同类型值可以执行的操作也不同. 对于引用类型的值, 我们可以为其添加属性和方法. 但是我们不能为基本类型的值添加属性, 尽管这样做不会导致任何错误.  
### 复制变量值  
在从一个变量向另一个变量复制基本类型和引用类型时, 也存在不同.  
如果从一个变量向另一个变量复制基本类型的值, 会在变量对象上创建一个新值, 然后把该值复制到为新变量分配的位置上.  
当从一个变量向另一个变量复制引用类型的值时, 同样也会将存储在变量对象中的值复制一份放到为新变量分配的空间. 不同的是, 这个值的副本实际上是一个指针, 而这个指针指向存储在堆中的一个对. 复制结束后, 两个变量实际上引用同一个对象. 因此, 改变其中一个变量, 就会影响到另一个变量.  
### 传递参数  
ECMASript 中所有函数的参数都是按值传递的. 也就是说, 把函数外部的值复制给函数内部的参数, 就是把值从一个变量复制到另一个变量一样. 在向参数传递基本类型的值时, 被传递的值会被复制给一个局部变量(即命名参数, 也就是arguments对象中一个元素). 在向参数传递引用类型的值时, 会把这个值在内存中的地址复制给一个局部变量, 因此这个局部变量的变化会反应在函数的外部.  

很多人会错误的以为: 在局部作用域中修改的对象会在全局作用域中反应出来, 就说明参数传递时按引用传递的.  
```JavaScript
function setName(obj){
    obj.name = 'shannon';
}

var person = new Object();
setName(person);
console.log(person.name);  //'shannon'
```

```JavaScript
//证明对象是按值传递的
function setName(obj){
    obj.name = 'shannon';
    obj = new Object();
    obj.name = 'lennon';
}

var person = new Object();
setName(person);
console.log(person.name);  //'shannon'
```
### 检测类型  
typeof 操作符检测一个变量是不是基本数据类型, 即是字符串, 数值, 布尔型还是undefined. 如果变量的值是一个对象或null, 则typeof 操作符会返回'object'
```JavaScript
var a = 'shannon';
var b = true;
var c = 22;
var d ;
var e = null;
var o = new Obejct();
alert(typeof a);  //string
alert(typeof b);  //boolean
alert(typeof c);  //number
alert(typeof d);  //undefined
alert(typeof e);  //object
alert(typeof o);  //object
```

```JavaScript
var color = new Array();
console.log(colors instanceof Array)  //true
```
所有引用类型的值都是Object 的实例, 所以在检测一个引用类型值和Object 构造函数时, instanceof 操作符始终会返回true. 如果使用instanceof 操作符检测基本数据类型的值, 则该操作符始终会返回false, 因为基本数据类型不是对象.  
## 执行环境及作用域  
执行环境( execution context )定义了变量或函数有权访问的其他数据, 决定了它们各自的行为. 每个执行环境都有一个与之关联的变量对象( variable object ), 环境中定义的所有变量和函数都保存在这个对象中. 虽然我们在编写的代码无法访问这个对象, 但解析器在处理数据时会在后台使用它.  

全局执行环境是最外围的一个执行环境(根据ECMASript 实现所在的宿主环境不同, 表示执行环境的对象也不一样. 在web 浏览器中, 全局执行环境是window 对象, 因此所有全局变量和函数都是作为window 对象的属性和方法创建的).某个执行环境中所有代码执行完毕后, 该环境被销毁, 保存在其中的所有变量和函数定义也随之销毁(全局执行环境知道应用程序退出--在关闭网页或浏览器--时才会被销毁)  

每个函数都有自己的执行环境, 当执行流进入一个函数时, 函数的执行环境就会被推入一个环境栈中. 而在函数执行之后, 栈将其环境弹出, 把控制权返回给之前的执行环境. ECMASript 程序中的执行流正是由这个方便的机制控制着.  

当代码在一个环境中执行时, 会创建变量对象的一个作用域链. 作用域链的用途是保证对执行环境有权访问的所有变量和函数的有权访问. 作用域的前端,始终是当前执行的代码所在环境的变量对象. 如果这个环境是函数, 则将其活动对象( activation object )作为变量对象. 活动对象在最开始时只包含一个变量, 即arguments 对象(这个对象在全局环境中是不存在的). 作用域链中的下一个变量对象来自包含(外部)环境, 而再下一个变量对象则是来自下一个包含环境. 这样, 一直延伸到全局执行环境, 全局执行环境的变量对象始终都是作用域链中的最后一个对象.  

标识符解析是沿着作用域链一级一级的搜索标识符的过程. 搜索过程始终从作用域链的前端开始, 然后逐级地往后回溯, 直至找到标识符为止(如果找不到标识符,通常会导致错误发生).  

```JavaScript
var color = 'blue';

function changeColor(){
    if(color === 'blue'){
        color = 'red';
    }else{
        color = 'blue';
    }
}

changeColor();
alert('color is now ' + color);  //red
```
在这个例子中, 函数changeColor() 的作用域链包含两个对象: 自己的变量对象(其中定义着arguments对象) 和全局环境的变量对象.  

## 延长作用域链  
虽然执行环境的类型总共只有两种--全局和局部(函数), 但还是有其他办法来延长作用域链的. 因为有些语句可以在作用域链的前端临时增加一个变量对象, 该变量对象会在代码执行后被移除.   
- try-catch 语句的catch 块;  
catch 语句会创建一个新的变量对象, 其中包含的是被抛出的错误对象的声明.
- with 语句  
with 语句会将指定的对象添加到作用域链中  

## 没有块级作用域  
其他类C的语言中, 由花括号封闭的代码块都有自己的作用域( ECMASript 中就是自己的执行环境 ), 在JavaScript 中,if 语句中的变量声明会将变量添加到当前的执行环境中. ( 在使用for 语句时要牢记 )  
```JavaScript
for(var i = 0; i < 10; i++){
    dosomething(i);
}
console.log(i)  //10
//i 会存在于循环外部的执行环境中
```
#### 声明变量  
使用var 声明的变量会自动被添加到最接近的环境中, 在函数内部, 最接近的环境就是函数的局部环境; 在with 语句中, 最接近的环境是函数环境. 如果出事换变量时没有使用var 声明, 该变量会自动被添加到全局环境中.  

#### 查询标识符  
当在某个环境中为了读取或写入而引入一个标识符时, 必须通过搜索来确定该标识符实际代表什么. 搜索过程从作用域链的前端开始, 向上逐级查询与给定名字匹配的标识符. 如果在局部环境中找到了该标识符, 搜索停止, 变量就绪. 如果在局部环境中没有找到该变量名, 则继续沿着作用域链向上搜索. 搜索过程一直追溯到全局环境的变量对象. 如果在全局环境中也没有找到这个标识符, 则意味着该变量没有事声明.  

>变量查询也是有代价的. 访问局部变量要比访问全局变量更快, 因为不用向上搜索作用域链.  

## 垃圾收集  
垃圾收集机制的原理: 找到那些不再继续使用的变量, 然后释放其占用的内存. 为此, 垃圾收集器会按照固定的时间间隔( 或代码执行中预定的收集时间 ), 周期性的执行这一操作.  

局部变量生命周期: 局部变量只在函数执行的过程中存在. 在这个过程中, 会为局部变量在栈(或堆)内存上分配相应的空间, 以便存储他们的值. 然后在函数中使用这些变量, 直至函数执行结束.  

标识无用变量的策略: 
- 标记清除( 最常用 )  
- 引用计数  

### 标记清除  
当变量进入环境中, 就将这个变量标记为 '进入环境', 从逻辑上讲, 永远不能释放进入环境的变量所占用的内存, 因为只要执行流进入相应的环境, 就有可能会用到他们. 当变量离开环境时, 就将其标记为 '离开环境'. 垃圾收集器会给内存中所有变量都添加标记, 然后去掉环境中的变量以及被环境中变量引用的变量的标记, 之后去掉所有被标记的变量, 即完成内存清除( 销毁那些标记的值, 并回收他们的内存).  

### 引用计数  
引用计数的含义是跟踪记录每个值被引用的次数. 当声明了一个变量并将一个引用类型值赋给该变量时, 这个值的引用次数就是1, 如果同一个值又被赋值给另一个变量, 则该值的引用次数加1. 相反, 如果包含这个值的引用的变量又取得另一个值, 则这个值的引用次数减1. 当这个值的引用次数变成0时,则说明没有办法再访问这个值了, 因此就可以将其占用的内存空间回收回来.  





